# Documentation

This documentation describes implementation details, core concepts are explained in the README.md.  
Due to the nature of client-side encryption, almost everything is done on the client.

## State of the project

This is beta. I'm actually not 100% sure about the cryptography yet, so that might have to change, but I think this serves as a good base already.

## Terminology

- **ID** the ID/name/link of the user, it will be used in the urls /ID#PASSWORD
- **PASSWORD** the PASSWORD the frontend uses for en-/decryption of the data
- **SECRET** the SECRET for the link to edit the business card

## API

The API has the a single endpoint:

```uri
/api/ID[/SECRET]
```

with multiple methods:

```txt
GET:    read
POST:   add
PUT:    update
DELETE: delete
```

### POST /api/new/ID

The first thing a user does is creating their business card.  
The frontend will encrypt a json and this endpoint will save it.  
It creates a folder with the name of ID and saves the encrypted data with a randomly generated filename inside it.  
This randomly generated filename is the SECRET for edit links.

If everything works out well, it returns something like this:

```json
{"success":true,"secret":"SECRET","error":""}
```

If it failed, responses contain an error field with a human readable error.  
This secret can then be used to construct the link for editing the business card.

### GET /api/read/ID

If the ID exists and nothing went wrong, this endpoint will return the encrypted data as utf-8 text.  
It returns nothing if there was an error, most likely because the ID doesn't exist.

### PUT /api/edit/ID/SECRET

Saves the body of the request in a file named after SECRET in the directory ID, if this file exists.  
It returns `{"success":true}` and contains a human readable error field if it wasn't successful, e.g.:

```json
{"success":false,"error":"nonexistant id or wrong secret"}
```

### DELETE /api/delete/ID/SECRET

Deletes the business card, it returns something like this:

```json
{"success":true,"error":""}
```

This is available not in the frontend yet.

## Frontend

Since the backend is basically just CRUD, most stuff is done in the frontend.  
Business cards are described in jsons, to get an overview here's a simple example:

```json
{
  "version": "0.0.3-beta",
  "style": "hand-drawn-dark",
  "fullname": "Your Name",
  "bio": "Add text here",
  "entries": [
    {
      "type": "website",
      "value": "https://example.com",
      "displayname": "example.com"
    }
  ],
  "cleanurl": false,
  "img": ""
}
```

The frontend uses these jsons to build the business cards.  
The card is seperated into "entries", entries are single pieces of information, like an email address.
The order of these entries is acknoleged when building the card.  

"cleanurl" is the setting that decides if the PASSWORD is removed from the url when loaded, this hides the crypto stuff, but also makes it harder people to save the url. (It's still in the browser history though, don't know a way around that.)

"version" is and indicator so we can detect version mismatches and migrate the jsons on breaking changes.  
Since the json is encrypted we have to do those migrations in the client.

"style" is used in urls to icons etc for personalisation.

### edit links

We do not have accounts or anything, instead people get a secret URL to edit the business card.  
Those links look like this /app/edit/ID/SECRET#PASSWORD.

Again, the PASSWORD is put in location.hash as we shouldn't know it, while the SECRET is known so it's ok for it to be in the path.

### Crypto

Currently I just use `CryptoJS.AES.encrypt` from crypto-js, it's very possible that I will change this once I've done proper research.  
`window.crypto.getRandomValues` is used to generate the PASSWORD.

### Styles

Styles are saved in static/styles/style-id/.  
This style-id/ folder must must contain a style.css and all the icons as .svg files.  
The style must be added to static/styles/styles.json which contains metadata, like the name to render it and a sources field with links to the icon set.  
This data is there to credit the creators.

### /app/

Static html has been mapped to shorter links e.g. /app/new is ./html/new.html

### Migrations

Migrations have to happen on the client, there's a very minimal and bad implementation of a migration from beta to 0.2-beta.  
Every braking change needs to be migrated in order to work.  
When a card is broken it will show an error and ask the user to go to the edit page for migration.  
In the future, migration could also happen only when reading, tho that seems risky.

### VCARD Generation

VCARD uploads were removed, the data structure allows for vcards to be generated more easily now.  
This is not implemented, but I imagien an autogenerated floaty button on every card to download the contact as .vcard.

## Deployment

I use docker, it should be easy without, my dockerfile is weird so I don't recommend it.
You should be able to run `sudo ./encrypted-cards -cert /path/to/fullchain.pem -key /path/to/keyfile.pem`.

### Docker

It expects a certs/ folder in the repo directory with fullchain.pem and privkey.pem (should be owned by root).

Build and tag the image:

```sh
sudo docker build . -t encrypted-cards:latest
```

It's set to serve on port 8080 and 8443 so it doesn't need capabilities to open privileged ports.

Spin up the container, -v give the container persistent storage, -p to map to the real ports again:

```sh
docker run -v /businesscards:/app/businesscards -p 80:8080 -p 443:8443 encrypted-cards
```
